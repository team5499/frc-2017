{
  "version": 3,
  "file": "targetFactory.js",
  "sourceRoot": "",
  "sources": [
    "../../src/targets/targetFactory.ts"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA,AAAO,AAAQ,AAAc,AAAE,AAAc,AAAE,AAAU,AAAE,AAAQ,AAAE,AAAM,AAAgB,AAAM,AAAuB;;;;;;AACxH,AAAO,AAAE,AAAQ,AAAE,AAAO,AAAE,AAAM,AAAuB;;;;;;AAGzD,AAAO,AAAE,AAAa,AAAE,AAAM,AAAiB;;;;;;AAE/C,MAAM,AAAc,iBAAG,IAAI,AAAG,IAAC,CAAC,AAAK,OAAE,AAAI,MAAE,AAAQ,UAAE,AAAQ,UAAE,AAAQ,UAAE,AAAS,AAAC,AAAC,AAEtF,AAAM;qCAAsC,AAAwB,KAAE,AAAqC,SAAE,AAAkB;AAC7H,UAAM,AAAM,SAAG,IAAI,AAAG,IAAC,AAAG,AAAC;AAC3B,UAAM,AAAW,cAAG,AAAQ,aAAK,AAAQ,+DAAC,AAAG,MAAG,AAAK,QAAG,AAAO,QAAC,AAAI;AACpE,AAAG,AAAC,SAAC,MAAM,AAAM,UAAI,AAAO,mEAAC,AAAO,QAAC,AAAM,AAAC,QAAC,AAAG,IAAe,AAAE,MAAI,OAAO,AAAE,OAAK,AAAQ,WAAG,EAAC,AAAM,QAAE,AAAE,AAAC,OAAG,AAAE,AAAC,AAAC,KAAC,AAAC;AACjH,YAAI,AAAI,OAAG,AAAM,OAAC,AAAM;AACxB,YAAI,AAAK,QAAG,AAAM,OAAC,AAAI;AACvB,cAAM,AAAS,YAAG,AAAI,KAAC,AAAW,YAAC,AAAG,AAAC;AACvC,AAAE,AAAC,YAAC,AAAS,YAAG,AAAC,AAAC,GAAC,AAAC;AAClB,AAAI,mBAAG,AAAM,OAAC,AAAM,OAAC,AAAS,UAAC,AAAC,GAAE,AAAS,AAAC;AAC5C,AAAE,AAAC,gBAAC,AAAK,SAAI,AAAI,AAAC,MAAC,AAAC;AAClB,AAAK,wBAAG,AAAM,OAAC,AAAM,OAAC,AAAS,UAAC,AAAS,YAAG,AAAC,AAAC,AAChD;AAAC,AACH;AAAC;AAED,AAAG,AAAC,aAAC,MAAM,AAAI,QAAI,AAAO,mEAAC,AAAK,SAAI,AAAW,AAAC,AAAC,cAAC,AAAC;AACjD,AAAQ,gFAAC,AAAM,QAAE,AAAc,0EAAC,AAAI,AAAC,OAAE,AAAI,AAAC,AAC9C;AAAC,AACH;AAAC;AAED,AAAE,AAAC,QAAC,AAAM,OAAC,AAAI,SAAK,AAAC,AAAC,GAAC,AAAC;AACtB,AAAM,eAAC,AAAG,IAAC,AAAc,0EAAC,AAAW,AAAC,cAAE,AAAE,AAAC,AAC7C;AAAC;AAED,AAAM,WAAC,AAAM,AACf;AAAC,AAED,AAAM;uBAAwB,AAAiC,cAAE,AAAsB,SAAE,AAAc,QAAE,AAA+B,UAAE,AAAuC;AAC/K,UAAM,AAAM,SAAkB,AAAE;AAEhC,UAAM,AAAM,SAAG,CAAC,AAAY,MAAE,AAAmC;AAC/D,YAAI,AAAM,SAAG,AAAY,aAAC,AAAG,IAAC,AAAI,AAAC;AACnC,AAAE,AAAC,YAAC,AAAM,UAAI,AAAI,AAAC,MAAC,AAAC;AACnB,AAAM,qBAAG,AAAO,QAAC,AAAM,AAAC;AACxB,AAAY,yBAAC,AAAG,IAAC,AAAI,MAAE,AAAM,AAAC,AAChC;AAAC;AACD,AAAM,eAAC,AAAI,KAAC,AAAM,AAAC,AACrB;AAAC;AAED,UAAM,AAAO,UAAG,AAAgB,iBAAC,AAAO,SAAE,AAAQ,SAAC,AAAa,AAAC;AACjE,AAAQ,aAAC,AAAa,cAAC,AAAO,SAAE,AAAM,QAAE,AAAY,AAAC;AACrD,AAAM,WAAC,AAAM,AACf;AAAC;AAED,0BAA0B,AAAsB,SAAE,AAA4B;AAC5E,UAAM,AAAI,OAAkB,AAAE;AAC9B,AAAG,AAAC,SAAC,MAAM,AAAC,KAAI,AAAO,AAAC,SAAC,AAAC;AACxB,cAAM,AAAI,OAAG,AAAC,EAAC,AAAW,AAAE,cAAC,AAAI,AAAE;AACnC,AAAE,AAAC,YAAC,AAAI,AAAK,AAAc,AAAC,+EAAC,AAAC;AAC5B,AAAI,iBAAC,AAAI,AAAC,oCAAG,AAAa,AAAC,AAC7B;AAAC,AACD,AAAI,eAAC,AAAC;AACJ,AAAI,iBAAC,AAAI,KAAC,AAAI,AAAC,AACjB;AAAC,AACH;AAAC;AACD,AAAM,WAAC,AAAI,AACb;AAAC,AAED,AAAM;4BAA6B,AAAc,QAAE,AAAc,QAAE,AAA+B;AAChG,AAAE,AAAC,QAAC,AAAc,eAAC,AAAG,IAAC,AAAM,AAAC,AAAC,SAAC,AAAC;AAC/B,AAAM,eAAC,AAAI,AAAa,4DAAC,AAAM,QAAE,AAAM,QAAE,AAAQ,AAAC,AACpD;AAAC,AACD,AAAI,eAAK,AAAM,AAAK,AAAU,AAAC,6EAAC,AAAC;AAC/B,AAAM,eAAC,IAAI,AAAU,AAAC,AAAU,AAAC,AACnC;AAAC,AACD,AAAI,KAHC,AAAE,AAAC,MAGH,AAAC;AACJ,cAAM,IAAI,AAAK,AAAC,yBAAmB,AAAM,MAAE,AAAC,AAC9C;AAAC,AACH;AAAC,AAED,AAAM;MAAkB,AAAQ,AAAM;AACpC,QAAI,AAAM;AACR,cAAM,IAAI,AAAK,MAAC,AAAY,AAAC,AAC/B;AAAC;AAEK,AAAK,SAAX,AAAK,CAAO,AAAiB,WAAE,AAAU;AACvC,AAAW,AACb;;;AAAC,AACF",
  "sourcesContent": [
    "import { Arch, archFromString, DEFAULT_TARGET, DIR_TARGET, Platform, Target, TargetConfig } from \"electron-builder-core\"\nimport { addValue, asArray } from \"electron-builder-util\"\nimport { PlatformSpecificBuildOptions } from \"../metadata\"\nimport { PlatformPackager } from \"../platformPackager\"\nimport { ArchiveTarget } from \"./ArchiveTarget\"\n\nconst archiveTargets = new Set([\"zip\", \"7z\", \"tar.xz\", \"tar.lz\", \"tar.gz\", \"tar.bz2\"])\n\nexport function computeArchToTargetNamesMap(raw: Map<Arch, string[]>, options: PlatformSpecificBuildOptions, platform: Platform): Map<Arch, string[]> {\n  const result = new Map(raw)\n  const defaultArch = platform === Platform.MAC ? \"x64\" : process.arch\n  for (const target of asArray(options.target).map<TargetConfig>(it => typeof it === \"string\" ? {target: it} : it)) {\n    let name = target.target\n    let archs = target.arch\n    const suffixPos = name.lastIndexOf(\":\")\n    if (suffixPos > 0) {\n      name = target.target.substring(0, suffixPos)\n      if (archs == null) {\n        archs = target.target.substring(suffixPos + 1)\n      }\n    }\n\n    for (const arch of asArray(archs || defaultArch)) {\n      addValue(result, archFromString(arch), name)\n    }\n  }\n\n  if (result.size === 0) {\n    result.set(archFromString(defaultArch), [])\n  }\n\n  return result\n}\n\nexport function createTargets(nameToTarget: Map<String, Target>, rawList: Array<string>, outDir: string, packager: PlatformPackager<any>, cleanupTasks: Array<() => Promise<any>>): Array<Target> {\n  const result: Array<Target> = []\n\n  const mapper = (name: string, factory: (outDir: string) => Target) => {\n    let target = nameToTarget.get(name)\n    if (target == null) {\n      target = factory(outDir)\n      nameToTarget.set(name, target)\n    }\n    result.push(target)\n  }\n\n  const targets = normalizeTargets(rawList, packager.defaultTarget)\n  packager.createTargets(targets, mapper, cleanupTasks)\n  return result\n}\n\nfunction normalizeTargets(targets: Array<string>, defaultTarget: Array<string>): Array<string> {\n  const list: Array<string> = []\n  for (const t of targets) {\n    const name = t.toLowerCase().trim()\n    if (name === DEFAULT_TARGET) {\n      list.push(...defaultTarget)\n    }\n    else {\n      list.push(name)\n    }\n  }\n  return list\n}\n\nexport function createCommonTarget(target: string, outDir: string, packager: PlatformPackager<any>): Target {\n  if (archiveTargets.has(target)) {\n    return new ArchiveTarget(target, outDir, packager)\n  }\n  else if (target === DIR_TARGET) {\n    return new NoOpTarget(DIR_TARGET)\n  }\n  else {\n    throw new Error(`Unknown target: ${target}`)\n  }\n}\n\nexport class NoOpTarget extends Target {\n  get outDir(): string {\n    throw new Error(\"NoOpTarget\")\n  }\n\n  async build(appOutDir: string, arch: Arch): Promise<any> {\n    // no build\n  }\n}"
  ]
}
